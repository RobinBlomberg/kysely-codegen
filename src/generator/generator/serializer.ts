import type { DatabaseMetadata } from '../../introspector';
import type { AliasDeclarationNode } from '../ast/alias-declaration-node';
import type { ArrayExpressionNode } from '../ast/array-expression-node';
import type { ExportStatementNode } from '../ast/export-statement-node';
import type { ExpressionNode } from '../ast/expression-node';
import type { ExtendsClauseNode } from '../ast/extends-clause-node';
import type { GenericExpressionNode } from '../ast/generic-expression-node';
import { type IdentifierNode } from '../ast/identifier-node';
import type { ImportClauseNode } from '../ast/import-clause-node';
import type { ImportStatementNode } from '../ast/import-statement-node';
import type { InferClauseNode } from '../ast/infer-clause-node';
import type { InterfaceDeclarationNode } from '../ast/interface-declaration-node';
import type { LiteralNode } from '../ast/literal-node';
import type { MappedTypeNode } from '../ast/mapped-type-node';
import type { ObjectExpressionNode } from '../ast/object-expression-node';
import type { PropertyNode } from '../ast/property-node';
import type { RawExpressionNode } from '../ast/raw-expression-node';
import type { RuntimeEnumDeclarationNode } from '../ast/runtime-enum-declaration-node';
import type { StatementNode } from '../ast/statement-node';
import type { UnionExpressionNode } from '../ast/union-expression-node';
import type { GeneratorDialect } from '../dialect';
import { transform, type Overrides } from '../transformer/transformer';
import { toPascalCase, toScreamingSnakeCase } from '../utils/case-converter';
import type { RuntimeEnumsStyle } from './runtime-enums-style';
import { createSingularizer } from './singularizer';

const IDENTIFIER_REGEXP = /^[$A-Z_a-z][\w$]*$/;

export type SerializeFileOptions = {
  camelCase?: boolean;
  customImports?: Record<string, string>;
  defaultSchemas?: string[];
  overrides?: Overrides;
  typeMapping?: Record<string, string>;
};

type TypeScriptSerializerOptions = {
  runtimeEnums?: boolean | RuntimeEnumsStyle;
  singularize?: boolean | Record<string, string>;
  skipAutogeneratedFileComment?: boolean;
  typeOnlyImports?: boolean;
};

export abstract class Serializer {
  abstract serializeFile(
    metadata: DatabaseMetadata,
    dialect: GeneratorDialect,
    options?: SerializeFileOptions,
  ): string;
}

export class TypeScriptSerializer implements Serializer {
  readonly runtimeEnums: boolean | RuntimeEnumsStyle;
  readonly singularize: ((word: string) => string) | undefined;
  readonly skipAutogeneratedFileComment: boolean;
  readonly typeOnlyImports: boolean;

  constructor(options: TypeScriptSerializerOptions = {}) {
    this.runtimeEnums = options.runtimeEnums ?? false;
    this.skipAutogeneratedFileComment =
      options.skipAutogeneratedFileComment ?? false;
    this.typeOnlyImports = options.typeOnlyImports ?? true;

    if (options.singularize) {
      this.singularize = createSingularizer(options.singularize);
    }
  }

  serializeAliasDeclaration(node: AliasDeclarationNode) {
    const expression =
      node.body.type === 'Template' ? node.body.expression : node.body;
    let data = '';

    data += 'type ';
    data += node.id.name;

    if (node.body.type === 'Template') {
      data += '<';

      for (let i = 0; i < node.body.params.length; i++) {
        if (i >= 1) {
          data += ', ';
        }

        data += node.body.params[i]!;
      }

      data += '>';
    }

    data += ' = ';
    data += this.serializeExpression(expression);
    data += ';';

    return data;
  }

  serializeArrayExpression(node: ArrayExpressionNode) {
    const shouldParenthesize =
      node.values.type === 'InferClause' ||
      (node.values.type === 'UnionExpression' && node.values.args.length >= 2);
    let data = '';

    if (shouldParenthesize) {
      data += '(';
    }

    data += this.serializeExpression(node.values);

    if (shouldParenthesize) {
      data += ')';
    }

    data += '[]';

    return data;
  }

  serializeExportStatement(node: ExportStatementNode) {
    let data = '';

    data += 'export ';

    switch (node.argument.type) {
      case 'AliasDeclaration':
        data += this.serializeAliasDeclaration(node.argument);
        break;
      case 'InterfaceDeclaration':
        data += this.serializeInterfaceDeclaration(node.argument);
        break;
      case 'RuntimeEnumDeclaration':
        data += this.serializeRuntimeEnum(node.argument);
        break;
    }

    return data;
  }

  serializeExpression(node: ExpressionNode) {
    switch (node.type) {
      case 'ArrayExpression':
        return this.serializeArrayExpression(node);
      case 'ExtendsClause':
        return this.serializeExtendsClause(node);
      case 'GenericExpression':
        return this.serializeGenericExpression(node);
      case 'Identifier':
        return this.serializeIdentifier(node);
      case 'InferClause':
        return this.serializeInferClause(node);
      case 'Literal':
        return this.serializeLiteral(node);
      case 'MappedType':
        return this.serializeMappedType(node);
      case 'ObjectExpression':
        return this.serializeObjectExpression(node);
      case 'RawExpression':
        return this.serializeRawExpression(node);
      case 'UnionExpression':
        return this.serializeUnionExpression(node);
    }
  }

  serializeExtendsClause(node: ExtendsClauseNode) {
    let data = '';

    data += this.serializeExpression(node.checkType);
    data += ' extends ';
    data += this.serializeExpression(node.extendsType);
    data += '\n  ? ';
    data += this.serializeExpression(node.trueType);
    data += '\n  : ';
    data += this.serializeExpression(node.falseType);

    return data;
  }

  serializeFile(
    metadata: DatabaseMetadata,
    dialect: GeneratorDialect,
    options?: SerializeFileOptions,
  ) {
    let data = '';

    if (!this.skipAutogeneratedFileComment) {
      data += '/**\n';
      data += ' * This file was generated by kysely-codegen.\n';
      data += ' * Please do not edit it manually.\n';
      data += ' */\n\n';
    }

    data += this.serializeStatements(
      transform({
        camelCase: options?.camelCase,
        customImports: options?.customImports,
        defaultSchemas: options?.defaultSchemas,
        dialect,
        metadata,
        typeMapping: options?.typeMapping,
        overrides: options?.overrides,
        runtimeEnums: this.runtimeEnums,
      }),
    );

    return data;
  }

  serializeGenericExpression(node: GenericExpressionNode) {
    let data = '';

    data += node.name;
    data += '<';

    for (let i = 0; i < node.args.length; i++) {
      if (i >= 1) {
        data += ', ';
      }

      data += this.serializeExpression(node.args[i]!);
    }

    data += '>';

    return data;
  }

  serializeIdentifier(node: IdentifierNode) {
    return this.singularize && node.isTableIdentifier
      ? toPascalCase(this.singularize(node.name))
      : node.name;
  }

  serializeImportClause(node: ImportClauseNode) {
    let data = '';

    data += node.name;

    if (node.alias) {
      data += ' as ';
      data += node.alias;
    }

    return data;
  }

  serializeImportStatement(node: ImportStatementNode) {
    let data = '';
    let i = 0;

    data += 'import ';

    if (this.typeOnlyImports) {
      data += 'type ';
    }

    data += '{';

    for (const importClause of node.imports) {
      if (i >= 1) {
        data += ',';
      }

      data += ' ';
      data += this.serializeImportClause(importClause);
      i++;
    }

    data += ' } from ';
    data += JSON.stringify(node.moduleName);
    data += ';';

    return data;
  }

  serializeInferClause(node: InferClauseNode) {
    let data = '';

    data += 'infer ';
    data += node.name;

    return data;
  }

  serializeInterfaceDeclaration(node: InterfaceDeclarationNode) {
    let data = '';

    data += 'interface ';
    data += this.serializeIdentifier(node.id);
    data += ' ';
    data += this.serializeObjectExpression(node.body);

    return data;
  }

  serializeLiteral(node: LiteralNode) {
    return JSON.stringify(node.value);
  }

  serializeKey(key: string) {
    return IDENTIFIER_REGEXP.test(key) ? key : JSON.stringify(key);
  }

  serializeMappedType(node: MappedTypeNode) {
    let data = '';

    data += '{\n  [x: string]: ';
    data += this.serializeExpression(node.value);
    data += ' | undefined;\n}';

    return data;
  }

  serializeObjectExpression(node: ObjectExpressionNode) {
    let data = '';

    data += '{';

    if (node.properties.length > 0) {
      data += '\n';

      const sortedProperties = [...node.properties].sort((a, b) =>
        a.key.localeCompare(b.key),
      );

      for (const property of sortedProperties) {
        data += '  ';
        data += this.serializeProperty(property);
      }
    }

    data += '}';

    return data;
  }

  serializeProperty(node: PropertyNode) {
    let data = '';

    if (node.comment) {
      data += '/**\n';

      for (const line of node.comment.split(/\r?\n/)) {
        data += `   *${line ? ` ${line}` : ''}\n`;
      }

      data += '   */\n  ';
    }

    data += this.serializeKey(node.key);
    data += ': ';
    data += this.serializeExpression(node.value);
    data += ';\n';

    return data;
  }

  serializeRawExpression(node: RawExpressionNode) {
    return node.expression;
  }

  serializeRuntimeEnum(node: RuntimeEnumDeclarationNode) {
    let data = 'enum ';

    data += node.id.name;
    data += ' {\n';

    const members = [...node.members].sort(([a], [b]) => {
      return a.localeCompare(b);
    });

    for (const member of members) {
      data += '  ';

      if (this.runtimeEnums === 'pascal-case') {
        data += toPascalCase(member[0]);
      } else {
        data += toScreamingSnakeCase(member[0]);
      }

      data += ' = ';
      data += this.serializeLiteral(member[1]);
      data += ',';
      data += '\n';
    }

    data += '}';

    return data;
  }

  serializeStatements(nodes: StatementNode[]) {
    let data = '';
    let i = 0;

    for (const node of nodes) {
      if (i >= 1) {
        data += '\n';

        if (node.type !== 'ImportStatement') {
          data += '\n';
        }
      }

      switch (node.type) {
        case 'ExportStatement':
          data += this.serializeExportStatement(node);
          break;
        case 'ImportStatement':
          data += this.serializeImportStatement(node);
          break;
      }

      i++;
    }

    data += '\n';

    return data;
  }

  serializeUnionExpression(node: UnionExpressionNode) {
    let data = '';
    let i = 0;

    const sortedArgs = [...node.args].sort((a, b) => {
      if (a.type !== 'Identifier' || b.type !== 'Identifier') {
        return 0;
      }
      if (a.name === undefined || a.name === 'undefined') return 1;
      if (b.name === undefined || b.name === 'undefined') return -1;
      if (a.name === null || a.name === 'null') return 1;
      if (b.name === null || b.name === 'null') return -1;
      if (a.name < b.name) return -1;
      if (a.name > b.name) return 1;
      return 0;
    });

    for (const arg of sortedArgs) {
      if (i >= 1) {
        data += ' | ';
      }

      data += this.serializeExpression(arg);
      i++;
    }

    return data;
  }
}
