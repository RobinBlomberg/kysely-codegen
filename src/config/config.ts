import { cosmiconfigSync } from 'cosmiconfig';
import { z } from 'zod';
import { ArrayExpressionNode } from '../generator/ast/array-expression-node';
import { ExtendsClauseNode } from '../generator/ast/extends-clause-node';
import { GenericExpressionNode } from '../generator/ast/generic-expression-node';
import { IdentifierNode } from '../generator/ast/identifier-node';
import { InferClauseNode } from '../generator/ast/infer-clause-node';
import { LiteralNode } from '../generator/ast/literal-node';
import { MappedTypeNode } from '../generator/ast/mapped-type-node';
import { ObjectExpressionNode } from '../generator/ast/object-expression-node';
import { RawExpressionNode } from '../generator/ast/raw-expression-node';
import { UnionExpressionNode } from '../generator/ast/union-expression-node';
import type { RuntimeEnumsStyle } from '../generator/generator/runtime-enums-style';
import type { Serializer } from '../generator/generator/serializer';
import type { LogLevel } from '../generator/logger/log-level';
import { LOG_LEVELS } from '../generator/logger/log-level';
import { Logger } from '../generator/logger/logger';
import type { Overrides } from '../generator/transformer/transformer';
import { IntrospectorDialect } from '../introspector/dialect';
import type { DateParser } from '../introspector/dialects/postgres/date-parser';
import type { NumericParser } from '../introspector/dialects/postgres/numeric-parser';
import { DatabaseMetadata } from '../introspector/metadata/database-metadata';

export type Config = {
  /**
   * Use the Kysely `CamelCasePlugin`.
   */
  camelCase?: boolean;
  /**
   * Specify custom type imports, in JSON format. Use # for named imports.
   *
   * @example
   * ```ts
   * {
   *   InstantRange: './custom-types',
   *   MyType: './types#OriginalType',
   * }
   * ```
   */
  customImports?: CustomImports;
  /**
   * Specify which parser to use for PostgreSQL date values.
   *
   * @default 'timestamp'
   */
  dateParser?: DateParser;
  /**
   * Set the default schema(s) for the database connection.
   */
  defaultSchemas?: string[];
  /**
   * Explicitly set the SQL dialect.
   */
  dialect?: DialectName | null;
  /**
   * Generate types for PostgreSQL domains.
   */
  domains?: boolean;
  /**
   * Specify the path to an environment file to use.
   */
  envFile?: string | null;
  /**
   * Exclude tables that match the specified glob pattern.
   *
   * @example 'users'
   * @example '*.table'
   * @example 'secrets.*'
   * @example '*._*'
   */
  excludePattern?: string | null;
  /**
   * Only include tables that match the specified glob pattern.
   *
   * @example 'users'
   * @example '*.table'
   * @example 'secrets.*'
   * @example '*._*'
   */
  includePattern?: string | null;
  /**
   * Specify a custom logger.
   */
  logger?: Logger;
  /**
   * Set the terminal log level.
   *
   * @default 'warn'
   */
  logLevel?: LogLevel;
  /**
   * Specify which parser to use for PostgreSQL numeric values.
   *
   * @default 'string'
   */
  numericParser?: NumericParser;
  /**
   * Set the file build path.
   *
   * @default './node_modules/kysely-codegen/dist/db.d.ts'
   */
  outFile?: string | null;
  /**
   * Specify type overrides for specific table columns, in JSON format.
   *
   * @example
   * ```ts
   * {
   *   columns: {
   *     'table_name.column_name': '{ foo: \'bar\' }'
   *   }
   * }
   * ```
   */
  overrides?: Overrides;
  /**
   * Include partitions of PostgreSQL tables in the generated code.
   */
  partitions?: boolean;
  /**
   * Print the generated output to the terminal instead of a file.
   */
  print?: boolean;
  /**
   * Generate runtime enums instead of string unions for PostgreSQL enums.
   */
  runtimeEnums?: boolean | RuntimeEnumsStyle;
  /**
   * Specify a custom serializer.
   */
  serializer?: Serializer;
  /**
   * Singularize generated table names, e.g. `BlogPost` instead of `BlogPosts`.
   */
  singularize?: boolean | Record<string, string>;
  /**
   * Skip the autogenerated file comment at the top of the generated file.
   */
  skipAutogeneratedFileComment?: boolean;
  /**
   * Specify type mappings for database types, in JSON format.
   *
   * @example
   * ```ts
   * {
   *   timestamptz: 'Temporal.Instant',
   *   tstzrange: 'InstantRange',
   * }
   * ```
   */
  typeMapping?: Record<string, string>;
  /**
   * Generate code using the TypeScript 3.8+ `import type` syntax.
   *
   * @default true
   */
  typeOnlyImports?: boolean;
  /**
   * Set the database connection string URL. This may point to an environment
   * variable.
   *
   * @default 'env(DATABASE_URL)'
   */
  url?: string;
  /**
   * Verify that the generated types are up-to-date.
   */
  verify?: boolean;
};

export type CustomImports = Record<string, string>;

export type DialectName = z.infer<typeof dialectNameSchema>;

type LoadConfigResult = {
  config: unknown;
  filepath: string;
};

export const dialectNameSchema = z.enum([
  'bun-sqlite',
  'kysely-bun-sqlite',
  'libsql',
  'mssql',
  'mysql',
  'postgres',
  'sqlite',
  'worker-bun-sqlite',
]);

const expressionNodeSchema = z.union([
  z.instanceof(ArrayExpressionNode),
  z.instanceof(ExtendsClauseNode),
  z.instanceof(GenericExpressionNode),
  z.instanceof(IdentifierNode),
  z.instanceof(InferClauseNode),
  z.instanceof(LiteralNode),
  z.instanceof(MappedTypeNode),
  z.instanceof(ObjectExpressionNode),
  z.instanceof(RawExpressionNode),
  z.instanceof(UnionExpressionNode),
  z.string(),
]);

const overridesSchema = z
  .object({ columns: z.record(z.string(), expressionNodeSchema).optional() })
  .optional();

export const configSchema = z.object({
  camelCase: z.boolean().optional(),
  customImports: z.record(z.string(), z.string()).optional(),
  dateParser: z.enum<DateParser[]>(['string', 'timestamp']).optional(),
  defaultSchemas: z.array(z.string()).optional(),
  dialect: dialectNameSchema.nullable().optional(),
  domains: z.boolean().optional(),
  envFile: z.string().nullable().optional(),
  excludePattern: z.string().nullable().optional(),
  includePattern: z.string().nullable().optional(),
  logger: z.instanceof(Logger).optional(),
  logLevel: z.enum(LOG_LEVELS).optional(),
  numericParser: z
    .enum<NumericParser[]>(['number', 'number-or-string', 'string'])
    .optional(),
  outFile: z.string().nullable().optional(),
  overrides: overridesSchema.optional(),
  partitions: z.boolean().optional(),
  print: z.boolean().optional(),
  runtimeEnums: z
    .union([
      z.boolean(),
      z.enum<RuntimeEnumsStyle[]>(['pascal-case', 'screaming-snake-case']),
    ])
    .optional(),
  serializer: z
    .object({
      serializeFile: z.function({
        input: z.tuple([
          z.instanceof(DatabaseMetadata),
          z.instanceof(IntrospectorDialect),
          z
            .object({
              camelCase: z.boolean().optional(),
              customImports: z.record(z.string(), z.string()).optional(),
              defaultSchemas: z.string().array().optional(),
              overrides: overridesSchema.optional(),
              typeMapping: z.record(z.string(), z.string()).optional(),
            })
            .optional(),
        ]),
        output: z.string(),
      }),
    })
    .optional(),
  singularize: z
    .union([z.boolean(), z.record(z.string(), z.string())])
    .optional(),
  skipAutogeneratedFileComment: z.boolean().optional(),
  typeMapping: z.record(z.string(), z.string()).optional(),
  typeOnlyImports: z.boolean().optional(),
  url: z.string().optional(),
  verify: z.boolean().optional(),
});

export const defineConfig = (config: Config): Config => {
  return config;
};

export const loadConfig = (config?: {
  configFile?: string;
}): LoadConfigResult | null => {
  const explorer = cosmiconfigSync('kysely-codegen');
  return config?.configFile
    ? explorer.load(config.configFile)
    : explorer.search();
};
