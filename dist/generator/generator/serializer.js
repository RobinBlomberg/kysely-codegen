"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptSerializer = exports.Serializer = void 0;
const transformer_1 = require("../transformer/transformer");
const case_converter_1 = require("../utils/case-converter");
const singularizer_1 = require("./singularizer");
const IDENTIFIER_REGEXP = /^[$A-Z_a-z][\w$]*$/;
class Serializer {
}
exports.Serializer = Serializer;
class TypeScriptSerializer {
    constructor(options = {}) {
        this.runtimeEnums = options.runtimeEnums ?? false;
        this.skipAutogeneratedFileComment =
            options.skipAutogeneratedFileComment ?? false;
        this.typeOnlyImports = options.typeOnlyImports ?? true;
        if (options.singularize) {
            this.singularize = (0, singularizer_1.createSingularizer)(options.singularize);
        }
    }
    serializeAliasDeclaration(node) {
        const expression = node.body.type === 'Template' ? node.body.expression : node.body;
        let data = '';
        data += 'type ';
        data += node.id.name;
        if (node.body.type === 'Template') {
            data += '<';
            for (let i = 0; i < node.body.params.length; i++) {
                if (i >= 1) {
                    data += ', ';
                }
                data += node.body.params[i];
            }
            data += '>';
        }
        data += ' = ';
        data += this.serializeExpression(expression);
        data += ';';
        return data;
    }
    serializeArrayExpression(node) {
        const shouldParenthesize = node.values.type === 'InferClause' ||
            (node.values.type === 'UnionExpression' && node.values.args.length >= 2);
        let data = '';
        if (shouldParenthesize) {
            data += '(';
        }
        data += this.serializeExpression(node.values);
        if (shouldParenthesize) {
            data += ')';
        }
        data += '[]';
        return data;
    }
    serializeExportStatement(node) {
        let data = '';
        data += 'export ';
        switch (node.argument.type) {
            case 'AliasDeclaration':
                data += this.serializeAliasDeclaration(node.argument);
                break;
            case 'InterfaceDeclaration':
                data += this.serializeInterfaceDeclaration(node.argument);
                break;
            case 'RuntimeEnumDeclaration':
                data += this.serializeRuntimeEnum(node.argument);
                break;
        }
        return data;
    }
    serializeExpression(node) {
        switch (node.type) {
            case 'ArrayExpression':
                return this.serializeArrayExpression(node);
            case 'ExtendsClause':
                return this.serializeExtendsClause(node);
            case 'GenericExpression':
                return this.serializeGenericExpression(node);
            case 'Identifier':
                return this.serializeIdentifier(node);
            case 'InferClause':
                return this.serializeInferClause(node);
            case 'Literal':
                return this.serializeLiteral(node);
            case 'MappedType':
                return this.serializeMappedType(node);
            case 'ObjectExpression':
                return this.serializeObjectExpression(node);
            case 'RawExpression':
                return this.serializeRawExpression(node);
            case 'UnionExpression':
                return this.serializeUnionExpression(node);
        }
    }
    serializeExtendsClause(node) {
        let data = '';
        data += this.serializeExpression(node.checkType);
        data += ' extends ';
        data += this.serializeExpression(node.extendsType);
        data += '\n  ? ';
        data += this.serializeExpression(node.trueType);
        data += '\n  : ';
        data += this.serializeExpression(node.falseType);
        return data;
    }
    serializeFile(metadata, dialect, options) {
        let data = '';
        if (!this.skipAutogeneratedFileComment) {
            data += '/**\n';
            data += ' * This file was generated by kysely-codegen.\n';
            data += ' * Please do not edit it manually.\n';
            data += ' */\n\n';
        }
        data += this.serializeStatements((0, transformer_1.transform)({
            camelCase: options?.camelCase,
            customImports: options?.customImports,
            defaultSchemas: options?.defaultSchemas,
            dialect,
            metadata,
            typeMapping: options?.typeMapping,
            overrides: options?.overrides,
            runtimeEnums: this.runtimeEnums,
        }));
        return data;
    }
    serializeGenericExpression(node) {
        let data = '';
        data += node.name;
        data += '<';
        for (let i = 0; i < node.args.length; i++) {
            if (i >= 1) {
                data += ', ';
            }
            data += this.serializeExpression(node.args[i]);
        }
        data += '>';
        return data;
    }
    serializeIdentifier(node) {
        return this.singularize && node.isTableIdentifier
            ? (0, case_converter_1.toPascalCase)(this.singularize(node.name))
            : node.name;
    }
    serializeImportClause(node) {
        let data = '';
        data += node.name;
        if (node.alias) {
            data += ' as ';
            data += node.alias;
        }
        return data;
    }
    serializeImportStatement(node) {
        let data = '';
        let i = 0;
        data += 'import ';
        if (this.typeOnlyImports) {
            data += 'type ';
        }
        data += '{';
        for (const importClause of node.imports) {
            if (i >= 1) {
                data += ',';
            }
            data += ' ';
            data += this.serializeImportClause(importClause);
            i++;
        }
        data += ' } from ';
        data += JSON.stringify(node.moduleName);
        data += ';';
        return data;
    }
    serializeInferClause(node) {
        let data = '';
        data += 'infer ';
        data += node.name;
        return data;
    }
    serializeInterfaceDeclaration(node) {
        let data = '';
        data += 'interface ';
        data += this.serializeIdentifier(node.id);
        data += ' ';
        data += this.serializeObjectExpression(node.body);
        return data;
    }
    serializeLiteral(node) {
        return JSON.stringify(node.value);
    }
    serializeKey(key) {
        return IDENTIFIER_REGEXP.test(key) ? key : JSON.stringify(key);
    }
    serializeMappedType(node) {
        let data = '';
        data += '{\n  [x: string]: ';
        data += this.serializeExpression(node.value);
        data += ' | undefined;\n}';
        return data;
    }
    serializeObjectExpression(node) {
        let data = '';
        data += '{';
        if (node.properties.length > 0) {
            data += '\n';
            const sortedProperties = [...node.properties].sort((a, b) => a.key.localeCompare(b.key));
            for (const property of sortedProperties) {
                data += '  ';
                data += this.serializeProperty(property);
            }
        }
        data += '}';
        return data;
    }
    serializeProperty(node) {
        let data = '';
        if (node.comment) {
            data += '/**\n';
            for (const line of node.comment.split(/\r?\n/)) {
                data += `   *${line ? ` ${line}` : ''}\n`;
            }
            data += '   */\n  ';
        }
        data += this.serializeKey(node.key);
        data += ': ';
        data += this.serializeExpression(node.value);
        data += ';\n';
        return data;
    }
    serializeRawExpression(node) {
        return node.expression;
    }
    serializeRuntimeEnum(node) {
        let data = 'enum ';
        data += node.id.name;
        data += ' {\n';
        const members = [...node.members].sort(([a], [b]) => {
            return a.localeCompare(b);
        });
        for (const member of members) {
            data += '  ';
            if (this.runtimeEnums === 'pascal-case') {
                data += (0, case_converter_1.toPascalCase)(member[0]);
            }
            else {
                data += (0, case_converter_1.toScreamingSnakeCase)(member[0]);
            }
            data += ' = ';
            data += this.serializeLiteral(member[1]);
            data += ',';
            data += '\n';
        }
        data += '}';
        return data;
    }
    serializeStatements(nodes) {
        let data = '';
        let i = 0;
        for (const node of nodes) {
            if (i >= 1) {
                data += '\n';
                if (node.type !== 'ImportStatement') {
                    data += '\n';
                }
            }
            switch (node.type) {
                case 'ExportStatement':
                    data += this.serializeExportStatement(node);
                    break;
                case 'ImportStatement':
                    data += this.serializeImportStatement(node);
                    break;
            }
            i++;
        }
        data += '\n';
        return data;
    }
    serializeUnionExpression(node) {
        let data = '';
        let i = 0;
        const sortedArgs = [...node.args].sort((a, b) => {
            if (a.type !== 'Identifier' || b.type !== 'Identifier') {
                return 0;
            }
            if (a.name === undefined || a.name === 'undefined')
                return 1;
            if (b.name === undefined || b.name === 'undefined')
                return -1;
            if (a.name === null || a.name === 'null')
                return 1;
            if (b.name === null || b.name === 'null')
                return -1;
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        });
        for (const arg of sortedArgs) {
            if (i >= 1) {
                data += ' | ';
            }
            data += this.serializeExpression(arg);
            i++;
        }
        return data;
    }
}
exports.TypeScriptSerializer = TypeScriptSerializer;
//# sourceMappingURL=serializer.js.map