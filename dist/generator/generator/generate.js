"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeFromMetadata = exports.generate = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const node_perf_hooks_1 = require("node:perf_hooks");
const constants_1 = require("../constants");
const diff_checker_1 = require("./diff-checker");
const serializer_1 = require("./serializer");
const generate = async (options) => {
    const startTime = node_perf_hooks_1.performance.now();
    options.logger?.info('Introspecting database...');
    const metadata = await options.dialect.introspector.introspect({
        db: options.db,
        excludePattern: options.excludePattern,
        includePattern: options.includePattern,
        partitions: options.partitions,
    });
    const newOutput = (0, exports.serializeFromMetadata)({ ...options, metadata, startTime });
    const outFile = options.outFile === undefined
        ? constants_1.DEFAULT_OUT_FILE
        : options.outFile === null
            ? null
            : (0, node_path_1.resolve)(process.cwd(), options.outFile);
    if (options.print) {
        console.info();
        console.info(newOutput);
    }
    else if (outFile) {
        if (options.verify) {
            const oldOutput = await node_fs_1.promises.readFile(outFile, 'utf8');
            const diffChecker = new diff_checker_1.DiffChecker();
            const diff = diffChecker.diff(newOutput, oldOutput);
            if (diff) {
                options.logger?.error(diff);
                throw new Error("Generated types are not up-to-date! Use '--log-level=error' option to view the diff.");
            }
            const endTime = node_perf_hooks_1.performance.now();
            const duration = Math.round(endTime - startTime);
            options.logger?.success(`Generated types are up-to-date! (${duration}ms)`);
        }
        else {
            const outDir = (0, node_path_1.parse)(outFile).dir;
            await node_fs_1.promises.mkdir(outDir, { recursive: true });
            await node_fs_1.promises.writeFile(outFile, newOutput);
            const endTime = node_perf_hooks_1.performance.now();
            const duration = Math.round(endTime - startTime);
            const tableCount = metadata.tables.length;
            const s = tableCount === 1 ? '' : 's';
            const relativePath = `.${node_path_1.sep}${(0, node_path_1.relative)(process.cwd(), outFile)}`;
            options.logger?.success(`Introspected ${tableCount} table${s} and generated ${relativePath} in ${duration}ms.\n`);
        }
    }
    else {
        options.logger?.success('No output file specified. Skipping file write.');
    }
    return newOutput;
};
exports.generate = generate;
const serializeFromMetadata = (options) => {
    options.logger?.debug();
    const s = options.metadata.tables.length === 1 ? '' : 's';
    options.logger?.debug(`Found ${options.metadata.tables.length} public table${s}:`);
    for (const table of options.metadata.tables) {
        options.logger?.debug(` - ${table.name}`);
    }
    options.logger?.debug();
    const serializer = options.serializer ??
        new serializer_1.TypeScriptSerializer({
            runtimeEnums: options.runtimeEnums,
            singularize: options.singularize,
            skipAutogeneratedFileComment: options.skipAutogeneratedFileComment,
            typeOnlyImports: options.typeOnlyImports,
        });
    return serializer.serializeFile(options.metadata, options.dialect, {
        camelCase: options.camelCase,
        customImports: options.customImports,
        defaultSchemas: options.defaultSchemas,
        overrides: options.overrides,
        typeMapping: options.typeMapping,
    });
};
exports.serializeFromMetadata = serializeFromMetadata;
//# sourceMappingURL=generate.js.map