"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configSchema = exports.dialectNameSchema = void 0;
const zod_1 = require("zod");
const generator_1 = require("../generator");
const introspector_1 = require("../introspector");
exports.dialectNameSchema = zod_1.z.enum([
    'bun-sqlite',
    'clickhouse',
    'kysely-bun-sqlite',
    'libsql',
    'mssql',
    'mysql',
    'postgres',
    'sqlite',
    'worker-bun-sqlite',
]);
const expressionNodeSchema = zod_1.z.union([
    zod_1.z.instanceof(generator_1.ArrayExpressionNode),
    zod_1.z.instanceof(generator_1.ExtendsClauseNode),
    zod_1.z.instanceof(generator_1.GenericExpressionNode),
    zod_1.z.instanceof(generator_1.IdentifierNode),
    zod_1.z.instanceof(generator_1.InferClauseNode),
    zod_1.z.instanceof(generator_1.LiteralNode),
    zod_1.z.instanceof(generator_1.MappedTypeNode),
    zod_1.z.instanceof(generator_1.ObjectExpressionNode),
    zod_1.z.instanceof(generator_1.RawExpressionNode),
    zod_1.z.instanceof(generator_1.UnionExpressionNode),
    zod_1.z.string(),
]);
const overridesSchema = zod_1.z
    .object({ columns: zod_1.z.record(zod_1.z.string(), expressionNodeSchema).optional() })
    .optional();
exports.configSchema = zod_1.z.object({
    camelCase: zod_1.z.boolean().optional(),
    customImports: zod_1.z.record(zod_1.z.string(), zod_1.z.string()).optional(),
    dateParser: zod_1.z.enum(['string', 'timestamp']).optional(),
    defaultSchemas: zod_1.z.array(zod_1.z.string()).optional(),
    dialect: exports.dialectNameSchema.optional(),
    domains: zod_1.z.boolean().optional(),
    envFile: zod_1.z.string().optional(),
    excludePattern: zod_1.z.string().nullable().optional(),
    includePattern: zod_1.z.string().nullable().optional(),
    logger: zod_1.z.instanceof(generator_1.Logger).optional(),
    logLevel: zod_1.z.enum(generator_1.LOG_LEVELS).optional(),
    numericParser: zod_1.z
        .enum(['number', 'number-or-string', 'string'])
        .optional(),
    outFile: zod_1.z.string().nullable().optional(),
    overrides: overridesSchema.optional(),
    partitions: zod_1.z.boolean().optional(),
    print: zod_1.z.boolean().optional(),
    runtimeEnums: zod_1.z
        .union([
        zod_1.z.boolean(),
        zod_1.z.enum(['pascal-case', 'screaming-snake-case']),
    ])
        .optional(),
    serializer: zod_1.z
        .object({
        serializeFile: zod_1.z.function({
            input: zod_1.z.tuple([
                zod_1.z.instanceof(introspector_1.DatabaseMetadata),
                zod_1.z.instanceof(introspector_1.IntrospectorDialect),
                zod_1.z
                    .object({
                    camelCase: zod_1.z.boolean().optional(),
                    customImports: zod_1.z.record(zod_1.z.string(), zod_1.z.string()).optional(),
                    defaultSchemas: zod_1.z.string().array().optional(),
                    overrides: overridesSchema.optional(),
                    typeMapping: zod_1.z.record(zod_1.z.string(), zod_1.z.string()).optional(),
                })
                    .optional(),
            ]),
            output: zod_1.z.string(),
        }),
    })
        .optional(),
    singularize: zod_1.z
        .union([zod_1.z.boolean(), zod_1.z.record(zod_1.z.string(), zod_1.z.string())])
        .optional(),
    skipAutogeneratedFileComment: zod_1.z.boolean().optional(),
    typeMapping: zod_1.z.record(zod_1.z.string(), zod_1.z.string()).optional(),
    typeOnlyImports: zod_1.z.boolean().optional(),
    url: zod_1.z.string().optional(),
    verify: zod_1.z.boolean().optional(),
});
//# sourceMappingURL=config.js.map